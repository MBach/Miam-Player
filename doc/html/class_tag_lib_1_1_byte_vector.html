<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Madame MiamMiam&#39;s Music Player: TagLib::ByteVector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Madame MiamMiam&#39;s Music Player
   &#160;<span id="projectnumber">0.5.0</span>
   </div>
   <div id="projectbrief">A nice music player</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_tag_lib_1_1_byte_vector.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="class_tag_lib_1_1_byte_vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TagLib::ByteVector Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A byte vector.  
 <a href="class_tag_lib_1_1_byte_vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tbytevector_8h_source.html">tbytevector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aae268d718d0d4c60ed400b63efe52856"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae268d718d0d4c60ed400b63efe52856"></a>
typedef std::vector&lt; char &gt;<br class="typebreak"/>
::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>Iterator</b></td></tr>
<tr class="separator:aae268d718d0d4c60ed400b63efe52856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f14363ec177112501c8cbdb32c03c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4f14363ec177112501c8cbdb32c03c0"></a>
typedef std::vector&lt; char &gt;<br class="typebreak"/>
::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>ConstIterator</b></td></tr>
<tr class="separator:ab4f14363ec177112501c8cbdb32c03c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e77c344a0d96cb1646cec496133879"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6e77c344a0d96cb1646cec496133879"></a>
typedef std::vector&lt; char &gt;<br class="typebreak"/>
::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>ReverseIterator</b></td></tr>
<tr class="separator:ad6e77c344a0d96cb1646cec496133879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900c221768ec2e7d4ab0955dfebd1c7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a900c221768ec2e7d4ab0955dfebd1c7f"></a>
typedef std::vector&lt; char &gt;<br class="typebreak"/>
::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>ConstReverseIterator</b></td></tr>
<tr class="separator:a900c221768ec2e7d4ab0955dfebd1c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af6e5b2614dacfc049b5b6e32063d4aa1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#af6e5b2614dacfc049b5b6e32063d4aa1">ByteVector</a> ()</td></tr>
<tr class="separator:af6e5b2614dacfc049b5b6e32063d4aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3bb27e43b76a1e3e40c8364ad7158c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a6e3bb27e43b76a1e3e40c8364ad7158c">ByteVector</a> (uint <a class="el" href="class_tag_lib_1_1_byte_vector.html#ad35dc30632085e7696660de9694bbc24">size</a>, char value=0)</td></tr>
<tr class="separator:a6e3bb27e43b76a1e3e40c8364ad7158c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613e5467e1b582775f98eed1e2f6c1ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a613e5467e1b582775f98eed1e2f6c1ef">ByteVector</a> (const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;v)</td></tr>
<tr class="separator:a613e5467e1b582775f98eed1e2f6c1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13926456683e40ab2846a3e5970b2c7d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a13926456683e40ab2846a3e5970b2c7d">ByteVector</a> (const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;v, uint offset, uint length)</td></tr>
<tr class="separator:a13926456683e40ab2846a3e5970b2c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa286e2ae6447e55e85ef855838d10c96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#aa286e2ae6447e55e85ef855838d10c96">ByteVector</a> (char c)</td></tr>
<tr class="separator:aa286e2ae6447e55e85ef855838d10c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fee04984a628e55cf480d56604e9ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#ad3fee04984a628e55cf480d56604e9ce">ByteVector</a> (const char *<a class="el" href="class_tag_lib_1_1_byte_vector.html#a55d40ed1e9b9749e3895c845f1f26901">data</a>, uint length)</td></tr>
<tr class="separator:ad3fee04984a628e55cf480d56604e9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cd4cd25e6b8fbd6a795005478b08e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#aa3cd4cd25e6b8fbd6a795005478b08e0">ByteVector</a> (const char *<a class="el" href="class_tag_lib_1_1_byte_vector.html#a55d40ed1e9b9749e3895c845f1f26901">data</a>)</td></tr>
<tr class="separator:aa3cd4cd25e6b8fbd6a795005478b08e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b45e9a86728313ddef12a037acc73d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a34b45e9a86728313ddef12a037acc73d">~ByteVector</a> ()</td></tr>
<tr class="separator:a34b45e9a86728313ddef12a037acc73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3749ede91c16089c33992649eb0522c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a3749ede91c16089c33992649eb0522c8">setData</a> (const char *<a class="el" href="class_tag_lib_1_1_byte_vector.html#a55d40ed1e9b9749e3895c845f1f26901">data</a>, uint length)</td></tr>
<tr class="separator:a3749ede91c16089c33992649eb0522c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a5128d1503ddaf6e6f780ce4eeb184"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#af9a5128d1503ddaf6e6f780ce4eeb184">setData</a> (const char *<a class="el" href="class_tag_lib_1_1_byte_vector.html#a55d40ed1e9b9749e3895c845f1f26901">data</a>)</td></tr>
<tr class="separator:af9a5128d1503ddaf6e6f780ce4eeb184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d40ed1e9b9749e3895c845f1f26901"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a55d40ed1e9b9749e3895c845f1f26901">data</a> ()</td></tr>
<tr class="separator:a55d40ed1e9b9749e3895c845f1f26901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe39991f59ce978639ef48400b0891b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#affe39991f59ce978639ef48400b0891b">data</a> () const </td></tr>
<tr class="separator:affe39991f59ce978639ef48400b0891b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab347f103e6c2bba92fdf491031dc46ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#ab347f103e6c2bba92fdf491031dc46ba">mid</a> (uint index, uint length=0xffffffff) const </td></tr>
<tr class="separator:ab347f103e6c2bba92fdf491031dc46ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db625889dc6281783ae25d3733e0919"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a4db625889dc6281783ae25d3733e0919">at</a> (uint index) const </td></tr>
<tr class="separator:a4db625889dc6281783ae25d3733e0919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557c662441974ba731bfdf9a360df5ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a557c662441974ba731bfdf9a360df5ce">find</a> (const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;pattern, uint offset=0, int byteAlign=1) const </td></tr>
<tr class="separator:a557c662441974ba731bfdf9a360df5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90aea68062cbe53ccf454d724d6dd7a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a90aea68062cbe53ccf454d724d6dd7a6">find</a> (char c, uint offset=0, int byteAlign=1) const </td></tr>
<tr class="separator:a90aea68062cbe53ccf454d724d6dd7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c984d49bda6a270f62d98b6a2933e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a46c984d49bda6a270f62d98b6a2933e4">rfind</a> (const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;pattern, uint offset=0, int byteAlign=1) const </td></tr>
<tr class="separator:a46c984d49bda6a270f62d98b6a2933e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62281faaa15a69073f4b830ad576213"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#ab62281faaa15a69073f4b830ad576213">containsAt</a> (const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;pattern, uint offset, uint patternOffset=0, uint patternLength=0xffffffff) const </td></tr>
<tr class="separator:ab62281faaa15a69073f4b830ad576213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f330306a73bbd23d89f7c14a2126456"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a5f330306a73bbd23d89f7c14a2126456">startsWith</a> (const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;pattern) const </td></tr>
<tr class="separator:a5f330306a73bbd23d89f7c14a2126456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68505e709c3cc3061ca0de7a04251f46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a68505e709c3cc3061ca0de7a04251f46">endsWith</a> (const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;pattern) const </td></tr>
<tr class="separator:a68505e709c3cc3061ca0de7a04251f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2c71ba84454616e1310e6dc12f8aa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#adf2c71ba84454616e1310e6dc12f8aa8">replace</a> (const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;pattern, const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;with)</td></tr>
<tr class="separator:adf2c71ba84454616e1310e6dc12f8aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9d03a684dbba770e2871a2dfe1d55a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#afe9d03a684dbba770e2871a2dfe1d55a">endsWithPartialMatch</a> (const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;pattern) const </td></tr>
<tr class="separator:afe9d03a684dbba770e2871a2dfe1d55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff38e54fa184e9cf0c77182db200a6e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#aff38e54fa184e9cf0c77182db200a6e4">append</a> (const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;v)</td></tr>
<tr class="separator:aff38e54fa184e9cf0c77182db200a6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2e95380834f3a55d49df208befe88c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a2e2e95380834f3a55d49df208befe88c">clear</a> ()</td></tr>
<tr class="separator:a2e2e95380834f3a55d49df208befe88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35dc30632085e7696660de9694bbc24"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#ad35dc30632085e7696660de9694bbc24">size</a> () const </td></tr>
<tr class="separator:ad35dc30632085e7696660de9694bbc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7490c1075ad2e119a164fb5491fd44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#add7490c1075ad2e119a164fb5491fd44">resize</a> (uint <a class="el" href="class_tag_lib_1_1_byte_vector.html#ad35dc30632085e7696660de9694bbc24">size</a>, char padding=0)</td></tr>
<tr class="separator:add7490c1075ad2e119a164fb5491fd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99848a9fbcb7b39e16866a881e2b115f"><td class="memItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a99848a9fbcb7b39e16866a881e2b115f">begin</a> ()</td></tr>
<tr class="separator:a99848a9fbcb7b39e16866a881e2b115f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4c8b26244d1efc6f392062a3146e41"><td class="memItemLeft" align="right" valign="top">ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#aab4c8b26244d1efc6f392062a3146e41">begin</a> () const </td></tr>
<tr class="separator:aab4c8b26244d1efc6f392062a3146e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a1f28d1a51f7351733f2ef22090c34"><td class="memItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a53a1f28d1a51f7351733f2ef22090c34">end</a> ()</td></tr>
<tr class="separator:a53a1f28d1a51f7351733f2ef22090c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7a47ae21af8e3a02be6346c078f2b8"><td class="memItemLeft" align="right" valign="top">ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#acc7a47ae21af8e3a02be6346c078f2b8">end</a> () const </td></tr>
<tr class="separator:acc7a47ae21af8e3a02be6346c078f2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b3cc8251bedb5bbb3c917d5b30ea93"><td class="memItemLeft" align="right" valign="top">ReverseIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a01b3cc8251bedb5bbb3c917d5b30ea93">rbegin</a> ()</td></tr>
<tr class="separator:a01b3cc8251bedb5bbb3c917d5b30ea93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea66336e4fcd37c0a35dedc4e3f171c"><td class="memItemLeft" align="right" valign="top">ConstReverseIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a2ea66336e4fcd37c0a35dedc4e3f171c">rbegin</a> () const </td></tr>
<tr class="separator:a2ea66336e4fcd37c0a35dedc4e3f171c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a15e7cab535f22c8107992c66789d7"><td class="memItemLeft" align="right" valign="top">ReverseIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a18a15e7cab535f22c8107992c66789d7">rend</a> ()</td></tr>
<tr class="separator:a18a15e7cab535f22c8107992c66789d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13b347466e2603aaee43415e426a90f"><td class="memItemLeft" align="right" valign="top">ConstReverseIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#ab13b347466e2603aaee43415e426a90f">rend</a> () const </td></tr>
<tr class="separator:ab13b347466e2603aaee43415e426a90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab3712f32591b5af95f3fe43421f704"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a3ab3712f32591b5af95f3fe43421f704">isNull</a> () const </td></tr>
<tr class="separator:a3ab3712f32591b5af95f3fe43421f704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4db491627843669c3d26263f18ef72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#abf4db491627843669c3d26263f18ef72">isEmpty</a> () const </td></tr>
<tr class="separator:abf4db491627843669c3d26263f18ef72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae497a9e2f33d7e7cd78558a6991db707"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#ae497a9e2f33d7e7cd78558a6991db707">checksum</a> () const </td></tr>
<tr class="separator:ae497a9e2f33d7e7cd78558a6991db707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f234fafaa7cb0f13c85a7aed996e4a4"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a1f234fafaa7cb0f13c85a7aed996e4a4">toUInt</a> (bool mostSignificantByteFirst=true) const </td></tr>
<tr class="separator:a1f234fafaa7cb0f13c85a7aed996e4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d21bddd22b3413156b63de2a47e2632"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a7d21bddd22b3413156b63de2a47e2632">toUInt</a> (uint offset, bool mostSignificantByteFirst=true) const </td></tr>
<tr class="separator:a7d21bddd22b3413156b63de2a47e2632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b734670aeb26903b8638dda28cdb836"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a5b734670aeb26903b8638dda28cdb836">toUInt</a> (uint offset, uint length, bool mostSignificantByteFirst=true) const </td></tr>
<tr class="separator:a5b734670aeb26903b8638dda28cdb836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792be96ea5c9edb1d1eb9e987d0f0b1d"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a792be96ea5c9edb1d1eb9e987d0f0b1d">toShort</a> (bool mostSignificantByteFirst=true) const </td></tr>
<tr class="separator:a792be96ea5c9edb1d1eb9e987d0f0b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6b6137205ed9d3bb349d5be8d9c75b"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a1a6b6137205ed9d3bb349d5be8d9c75b">toShort</a> (uint offset, bool mostSignificantByteFirst=true) const </td></tr>
<tr class="separator:a1a6b6137205ed9d3bb349d5be8d9c75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa504bf38f98c782647ea46fbe7c9dc5c"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#aa504bf38f98c782647ea46fbe7c9dc5c">toUShort</a> (bool mostSignificantByteFirst=true) const </td></tr>
<tr class="separator:aa504bf38f98c782647ea46fbe7c9dc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff09612c4a59eb9598aa1063c53bf0c"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#aaff09612c4a59eb9598aa1063c53bf0c">toUShort</a> (uint offset, bool mostSignificantByteFirst=true) const </td></tr>
<tr class="separator:aaff09612c4a59eb9598aa1063c53bf0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398ca4acfe99175547dd239a2ed83730"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a398ca4acfe99175547dd239a2ed83730">toLongLong</a> (bool mostSignificantByteFirst=true) const </td></tr>
<tr class="separator:a398ca4acfe99175547dd239a2ed83730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9503dffeb3306b1c9f8fb849a11313bf"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a9503dffeb3306b1c9f8fb849a11313bf">toLongLong</a> (uint offset, bool mostSignificantByteFirst=true) const </td></tr>
<tr class="separator:a9503dffeb3306b1c9f8fb849a11313bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec096b29dc0f9222ca393692fae128a"><td class="memItemLeft" align="right" valign="top">const char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a2ec096b29dc0f9222ca393692fae128a">operator[]</a> (int index) const </td></tr>
<tr class="separator:a2ec096b29dc0f9222ca393692fae128a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c078f5864c875eb49a0e900336191e2"><td class="memItemLeft" align="right" valign="top">char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a6c078f5864c875eb49a0e900336191e2">operator[]</a> (int index)</td></tr>
<tr class="separator:a6c078f5864c875eb49a0e900336191e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e891841a6c5259b177498a19a91c758"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a9e891841a6c5259b177498a19a91c758">operator==</a> (const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;v) const </td></tr>
<tr class="separator:a9e891841a6c5259b177498a19a91c758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3918f3327686bc80a6022bf66fb86124"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a3918f3327686bc80a6022bf66fb86124">operator!=</a> (const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;v) const </td></tr>
<tr class="separator:a3918f3327686bc80a6022bf66fb86124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae63d46b0a9ddd6971c40502cb7835f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a0ae63d46b0a9ddd6971c40502cb7835f">operator==</a> (const char *s) const </td></tr>
<tr class="separator:a0ae63d46b0a9ddd6971c40502cb7835f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0167694c169d832fa0b1012a5d62d89c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a0167694c169d832fa0b1012a5d62d89c">operator!=</a> (const char *s) const </td></tr>
<tr class="separator:a0167694c169d832fa0b1012a5d62d89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264ff435cb7f79bd93ccdb1ba4d5c52f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a264ff435cb7f79bd93ccdb1ba4d5c52f">operator&lt;</a> (const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;v) const </td></tr>
<tr class="separator:a264ff435cb7f79bd93ccdb1ba4d5c52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3f661ccc7cf8309089e9b3a284d3bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a5c3f661ccc7cf8309089e9b3a284d3bc">operator&gt;</a> (const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;v) const </td></tr>
<tr class="separator:a5c3f661ccc7cf8309089e9b3a284d3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de1892f12726bb4d50276abd8f64edc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a5de1892f12726bb4d50276abd8f64edc">operator+</a> (const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;v) const </td></tr>
<tr class="separator:a5de1892f12726bb4d50276abd8f64edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac612d7f38571456c5f0083e07df554cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#ac612d7f38571456c5f0083e07df554cd">operator=</a> (const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;v)</td></tr>
<tr class="separator:ac612d7f38571456c5f0083e07df554cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8204c1556dee0a7f330962b8587381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a4a8204c1556dee0a7f330962b8587381">operator=</a> (char c)</td></tr>
<tr class="separator:a4a8204c1556dee0a7f330962b8587381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5947f410bee90e1cd36a0dd931113d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#aba5947f410bee90e1cd36a0dd931113d">operator=</a> (const char *<a class="el" href="class_tag_lib_1_1_byte_vector.html#a55d40ed1e9b9749e3895c845f1f26901">data</a>)</td></tr>
<tr class="separator:aba5947f410bee90e1cd36a0dd931113d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9839e48c11619907ad618a4d7399e76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#ae9839e48c11619907ad618a4d7399e76">toHex</a> () const </td></tr>
<tr class="separator:ae9839e48c11619907ad618a4d7399e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a680335d571501172e98df012aae52335"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a680335d571501172e98df012aae52335">fromUInt</a> (uint value, bool mostSignificantByteFirst=true)</td></tr>
<tr class="separator:a680335d571501172e98df012aae52335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162543bf4b280468a677799686178522"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a162543bf4b280468a677799686178522">fromShort</a> (short value, bool mostSignificantByteFirst=true)</td></tr>
<tr class="separator:a162543bf4b280468a677799686178522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b81a576453f38fb816294f1e77a76d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a51b81a576453f38fb816294f1e77a76d">fromLongLong</a> (long long value, bool mostSignificantByteFirst=true)</td></tr>
<tr class="separator:a51b81a576453f38fb816294f1e77a76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2782f08a6b8350c4e5f17548a60b5495"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a2782f08a6b8350c4e5f17548a60b5495">fromCString</a> (const char *s, uint length=0xffffffff)</td></tr>
<tr class="separator:a2782f08a6b8350c4e5f17548a60b5495"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7593a608427eb6f855c4dc48558ad8a4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a7593a608427eb6f855c4dc48558ad8a4">null</a></td></tr>
<tr class="separator:a7593a608427eb6f855c4dc48558ad8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aed0573f25ee917a40d6cd242b3115ae0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed0573f25ee917a40d6cd242b3115ae0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>detach</b> ()</td></tr>
<tr class="separator:aed0573f25ee917a40d6cd242b3115ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a36db251bf327d8f00dcee07367fd7cd5"><td class="memItemLeft" align="right" valign="top">TAGLIB_EXPORT std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tag_lib_1_1_byte_vector.html#a36db251bf327d8f00dcee07367fd7cd5">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="class_tag_lib_1_1_byte_vector.html">TagLib::ByteVector</a> &amp;v)</td></tr>
<tr class="separator:a36db251bf327d8f00dcee07367fd7cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A byte vector. </p>
<p>This class provides a byte vector with some methods that are useful for tagging purposes. Many of the search functions are tailored to what is useful for finding tag related paterns in a data array. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af6e5b2614dacfc049b5b6e32063d4aa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an empty byte vector. </p>

</div>
</div>
<a class="anchor" id="a6e3bb27e43b76a1e3e40c8364ad7158c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a vector of size <em>size</em> with all values set to <em>value</em> by default. </p>

</div>
</div>
<a class="anchor" id="a613e5467e1b582775f98eed1e2f6c1ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a byte vector that is a copy of <em>v</em>. </p>

</div>
</div>
<a class="anchor" id="a13926456683e40ab2846a3e5970b2c7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a byte vector that is a copy of <em>v</em>. </p>

</div>
</div>
<a class="anchor" id="aa286e2ae6447e55e85ef855838d10c96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a byte vector that contains <em>c</em>. </p>

</div>
</div>
<a class="anchor" id="ad3fee04984a628e55cf480d56604e9ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a byte vector that copies <em>data</em> for up to <em>length</em> bytes. </p>

</div>
</div>
<a class="anchor" id="aa3cd4cd25e6b8fbd6a795005478b08e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a byte vector that copies <em>data</em> up to the first null byte. The behavior is undefined if <em>data</em> is not null terminated. This is particularly useful for constructing byte arrays from string constants. </p>

</div>
</div>
<a class="anchor" id="a34b45e9a86728313ddef12a037acc73d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TagLib::ByteVector::~ByteVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys this <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a> instance. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aff38e54fa184e9cf0c77182db200a6e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a>&amp; TagLib::ByteVector::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends <em>v</em> to the end of the <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a>. </p>

</div>
</div>
<a class="anchor" id="a4db625889dc6281783ae25d3733e0919"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char TagLib::ByteVector::at </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This essentially performs the same as <a class="el" href="class_tag_lib_1_1_byte_vector.html#a2ec096b29dc0f9222ca393692fae128a">operator[]()</a>, but instead of causing a runtime error if the index is out of bounds, it will return a null byte. </p>

</div>
</div>
<a class="anchor" id="a99848a9fbcb7b39e16866a881e2b115f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Iterator TagLib::ByteVector::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an Iterator that points to the front of the vector. </p>

</div>
</div>
<a class="anchor" id="aab4c8b26244d1efc6f392062a3146e41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstIterator TagLib::ByteVector::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a ConstIterator that points to the front of the vector. </p>

</div>
</div>
<a class="anchor" id="ae497a9e2f33d7e7cd78558a6991db707"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint TagLib::ByteVector::checksum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a CRC checksum of the byte vector's data. </p>

</div>
</div>
<a class="anchor" id="a2e2e95380834f3a55d49df208befe88c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a>&amp; TagLib::ByteVector::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the data. </p>

</div>
</div>
<a class="anchor" id="ab62281faaa15a69073f4b830ad576213"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::containsAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>patternOffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>patternLength</em> = <code>0xffffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks to see if the vector contains the <em>pattern</em> starting at position <em>offset</em>. Optionally, if you only want to search for part of the pattern you can specify an offset within the pattern to start from. Also, you can specify to only check for the first <em>patternLength</em> bytes of <em>pattern</em> with the <em>patternLength</em> argument. </p>

</div>
</div>
<a class="anchor" id="a55d40ed1e9b9749e3895c845f1f26901"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* TagLib::ByteVector::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the internal data structure.</p>
<dl class="section warning"><dt>Warning</dt><dd>Care should be taken when modifying this data structure as it is easy to corrupt the <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a> when doing so. Specifically, while the data may be changed, its length may not be. </dd></dl>

</div>
</div>
<a class="anchor" id="affe39991f59ce978639ef48400b0891b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* TagLib::ByteVector::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the internal data structure which may not be modified. </p>

</div>
</div>
<a class="anchor" id="a53a1f28d1a51f7351733f2ef22090c34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Iterator TagLib::ByteVector::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an Iterator that points to the back of the vector. </p>

</div>
</div>
<a class="anchor" id="acc7a47ae21af8e3a02be6346c078f2b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstIterator TagLib::ByteVector::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a ConstIterator that points to the back of the vector. </p>

</div>
</div>
<a class="anchor" id="a68505e709c3cc3061ca0de7a04251f46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::endsWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the vector ends with <em>pattern</em>. </p>

</div>
</div>
<a class="anchor" id="afe9d03a684dbba770e2871a2dfe1d55a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TagLib::ByteVector::endsWithPartialMatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks for a partial match of <em>pattern</em> at the end of the vector. It returns the offset of the partial match within the vector, or -1 if the pattern is not found. This method is particularly useful when searching for patterns that start in one vector and end in another. When combined with <a class="el" href="class_tag_lib_1_1_byte_vector.html#a5f330306a73bbd23d89f7c14a2126456">startsWith()</a> it can be used to find a pattern that overlaps two buffers.</p>
<dl class="section note"><dt>Note</dt><dd>This will not match the complete pattern at the end of the string; use <a class="el" href="class_tag_lib_1_1_byte_vector.html#a68505e709c3cc3061ca0de7a04251f46">endsWith()</a> for that. </dd></dl>

</div>
</div>
<a class="anchor" id="a557c662441974ba731bfdf9a360df5ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TagLib::ByteVector::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteAlign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches the <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a> for <em>pattern</em> starting at <em>offset</em> and returns the offset. Returns -1 if the pattern was not found. If <em>byteAlign</em> is specified the pattern will only be matched if it starts on a byte divisible by <em>byteAlign</em> (starting from <em>offset</em>). </p>

</div>
</div>
<a class="anchor" id="a90aea68062cbe53ccf454d724d6dd7a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TagLib::ByteVector::find </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteAlign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches the char for <em>c</em> starting at <em>offset</em> and returns the offset. Returns <em>npos</em> if the pattern was not found. If <em>byteAlign</em> is specified the pattern will only be matched if it starts on a byte divisible by <em>byteAlign</em> (starting from <em>offset</em>). </p>

</div>
</div>
<a class="anchor" id="a2782f08a6b8350c4e5f17548a60b5495"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> TagLib::ByteVector::fromCString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>length</em> = <code>0xffffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a> based on the CString <em>s</em>. </p>

</div>
</div>
<a class="anchor" id="a51b81a576453f38fb816294f1e77a76d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> TagLib::ByteVector::fromLongLong </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a 8 byte <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a> based on <em>value</em>. If <em>mostSignificantByteFirst</em> is true, then this will operate left to right in building the <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a>. For example if <em>mostSignificantByteFirst</em> is true then $00 00 00 01 == 0x0000000000000001 == 1, if false, $01 00 00 00 00 00 00 00 == 0x0100000000000000 == 1.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_tag_lib_1_1_byte_vector.html#a398ca4acfe99175547dd239a2ed83730">toLongLong()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a162543bf4b280468a677799686178522"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> TagLib::ByteVector::fromShort </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a 2 byte <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a> based on <em>value</em>. If <em>mostSignificantByteFirst</em> is true, then this will operate left to right in building the <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a>. For example if <em>mostSignificantByteFirst</em> is true then $00 01 == 0x0001 == 1, if false, $01 00 == 0x0100 == 1.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_tag_lib_1_1_byte_vector.html#a792be96ea5c9edb1d1eb9e987d0f0b1d">toShort()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a680335d571501172e98df012aae52335"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> TagLib::ByteVector::fromUInt </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a 4 byte <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a> based on <em>value</em>. If <em>mostSignificantByteFirst</em> is true, then this will operate left to right in building the <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a>. For example if <em>mostSignificantByteFirst</em> is true then $00 00 00 01 == 0x00000001 == 1, if false, $01 00 00 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_tag_lib_1_1_byte_vector.html#a1f234fafaa7cb0f13c85a7aed996e4a4">toUInt()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abf4db491627843669c3d26263f18ef72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a> is empty.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_tag_lib_1_1_byte_vector.html#ad35dc30632085e7696660de9694bbc24">size()</a> </dd>
<dd>
<a class="el" href="class_tag_lib_1_1_byte_vector.html#a3ab3712f32591b5af95f3fe43421f704">isNull()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3ab3712f32591b5af95f3fe43421f704"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::isNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the vector is null.</p>
<dl class="section note"><dt>Note</dt><dd>A vector may be empty without being null. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_tag_lib_1_1_byte_vector.html#abf4db491627843669c3d26263f18ef72">isEmpty()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab347f103e6c2bba92fdf491031dc46ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> TagLib::ByteVector::mid </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>length</em> = <code>0xffffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a byte vector made up of the bytes starting at <em>index</em> and for <em>length</em> bytes. If <em>length</em> is not specified it will return the bytes from <em>index</em> to the end of the vector. </p>

</div>
</div>
<a class="anchor" id="a3918f3327686bc80a6022bf66fb86124"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a> and <em>v</em> are not equal. </p>

</div>
</div>
<a class="anchor" id="a0167694c169d832fa0b1012a5d62d89c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator!= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a> and the null terminated C string <em>s</em> do not contain the same data. </p>

</div>
</div>
<a class="anchor" id="a5de1892f12726bb4d50276abd8f64edc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> TagLib::ByteVector::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector that is <em>v</em> appended to this vector. </p>

</div>
</div>
<a class="anchor" id="a264ff435cb7f79bd93ccdb1ba4d5c52f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a> is less than <em>v</em>. The value of the vectors is determined by evaluating the character from left to right, and in the event one vector is a superset of the other, the size is used. </p>

</div>
</div>
<a class="anchor" id="ac612d7f38571456c5f0083e07df554cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a>&amp; TagLib::ByteVector::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a> <em>v</em>. </p>

</div>
</div>
<a class="anchor" id="a4a8204c1556dee0a7f330962b8587381"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a>&amp; TagLib::ByteVector::operator= </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a> <em>v</em>. </p>

</div>
</div>
<a class="anchor" id="aba5947f410bee90e1cd36a0dd931113d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a>&amp; TagLib::ByteVector::operator= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a> <em>v</em>. </p>

</div>
</div>
<a class="anchor" id="a9e891841a6c5259b177498a19a91c758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a> and <em>v</em> are equal. </p>

</div>
</div>
<a class="anchor" id="a0ae63d46b0a9ddd6971c40502cb7835f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator== </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a> and the null terminated C string <em>s</em> contain the same data. </p>

</div>
</div>
<a class="anchor" id="a5c3f661ccc7cf8309089e9b3a284d3bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a> is greater than <em>v</em>. </p>

</div>
</div>
<a class="anchor" id="a2ec096b29dc0f9222ca393692fae128a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char&amp; TagLib::ByteVector::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a const refernence to the byte at <em>index</em>. </p>

</div>
</div>
<a class="anchor" id="a6c078f5864c875eb49a0e900336191e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char&amp; TagLib::ByteVector::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a reference to the byte at <em>index</em>. </p>

</div>
</div>
<a class="anchor" id="a01b3cc8251bedb5bbb3c917d5b30ea93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ReverseIterator TagLib::ByteVector::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a ReverseIterator that points to the front of the vector. </p>

</div>
</div>
<a class="anchor" id="a2ea66336e4fcd37c0a35dedc4e3f171c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstReverseIterator TagLib::ByteVector::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a ConstReverseIterator that points to the front of the vector. </p>

</div>
</div>
<a class="anchor" id="a18a15e7cab535f22c8107992c66789d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ReverseIterator TagLib::ByteVector::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a ReverseIterator that points to the back of the vector. </p>

</div>
</div>
<a class="anchor" id="ab13b347466e2603aaee43415e426a90f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstReverseIterator TagLib::ByteVector::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a ConstReverseIterator that points to the back of the vector. </p>

</div>
</div>
<a class="anchor" id="adf2c71ba84454616e1310e6dc12f8aa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a>&amp; TagLib::ByteVector::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>with</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces <em>pattern</em> with <em>with</em> and returns a reference to the <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a> after the operation. This <em>does</em> modify the vector. </p>

</div>
</div>
<a class="anchor" id="add7490c1075ad2e119a164fb5491fd44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a>&amp; TagLib::ByteVector::resize </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>padding</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resize the vector to <em>size</em>. If the vector is currently less than <em>size</em>, pad the remaining spaces with <em>padding</em>. Returns a reference to the resized vector. </p>

</div>
</div>
<a class="anchor" id="a46c984d49bda6a270f62d98b6a2933e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TagLib::ByteVector::rfind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteAlign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches the <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a> for <em>pattern</em> starting from either the end of the vector or <em>offset</em> and returns the offset. Returns -1 if the pattern was not found. If <em>byteAlign</em> is specified the pattern will only be matched if it starts on a byte divisible by <em>byteAlign</em> (starting from <em>offset</em>). </p>

</div>
</div>
<a class="anchor" id="a3749ede91c16089c33992649eb0522c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a>&amp; TagLib::ByteVector::setData </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the data for the byte array using the first <em>length</em> bytes of <em>data</em> </p>

</div>
</div>
<a class="anchor" id="af9a5128d1503ddaf6e6f780ce4eeb184"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a>&amp; TagLib::ByteVector::setData </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the data for the byte array copies <em>data</em> up to the first null byte. The behavior is undefined if <em>data</em> is not null terminated. </p>

</div>
</div>
<a class="anchor" id="ad35dc30632085e7696660de9694bbc24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint TagLib::ByteVector::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size of the array. </p>

</div>
</div>
<a class="anchor" id="a5f330306a73bbd23d89f7c14a2126456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::startsWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the vector starts with <em>pattern</em>. </p>

</div>
</div>
<a class="anchor" id="ae9839e48c11619907ad618a4d7399e76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> TagLib::ByteVector::toHex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a hex-encoded copy of the byte vector. </p>

</div>
</div>
<a class="anchor" id="a398ca4acfe99175547dd239a2ed83730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long TagLib::ByteVector::toLongLong </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the first 8 bytes of the vector to a (signed) long long.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 00 00 00 00 00 00 01 == 0x0000000000000001 == 1, if false, $01 00 00 00 00 00 00 00 == 0x0100000000000000 == 1.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_tag_lib_1_1_byte_vector.html#a680335d571501172e98df012aae52335">fromUInt()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9503dffeb3306b1c9f8fb849a11313bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long TagLib::ByteVector::toLongLong </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the 8 bytes at <em>offset</em> of the vector to a (signed) long long.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 00 00 00 00 00 00 01 == 0x0000000000000001 == 1, if false, $01 00 00 00 00 00 00 00 == 0x0100000000000000 == 1.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_tag_lib_1_1_byte_vector.html#a680335d571501172e98df012aae52335">fromUInt()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a792be96ea5c9edb1d1eb9e987d0f0b1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short TagLib::ByteVector::toShort </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the first 2 bytes of the vector to a (signed) short.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 $01 == 0x0001 == 1, if false, $01 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_tag_lib_1_1_byte_vector.html#a162543bf4b280468a677799686178522">fromShort()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1a6b6137205ed9d3bb349d5be8d9c75b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short TagLib::ByteVector::toShort </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the 2 bytes at <em>offset</em> of the vector to a (signed) short.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 $01 == 0x0001 == 1, if false, $01 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_tag_lib_1_1_byte_vector.html#a162543bf4b280468a677799686178522">fromShort()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1f234fafaa7cb0f13c85a7aed996e4a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint TagLib::ByteVector::toUInt </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the first 4 bytes of the vector to an unsigned integer.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 $00 $00 $01 == 0x00000001 == 1, if false, $01 00 00 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_tag_lib_1_1_byte_vector.html#a680335d571501172e98df012aae52335">fromUInt()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7d21bddd22b3413156b63de2a47e2632"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint TagLib::ByteVector::toUInt </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the 4 bytes at <em>offset</em> of the vector to an unsigned integer.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 $00 $00 $01 == 0x00000001 == 1, if false, $01 00 00 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_tag_lib_1_1_byte_vector.html#a680335d571501172e98df012aae52335">fromUInt()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5b734670aeb26903b8638dda28cdb836"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint TagLib::ByteVector::toUInt </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the <em>length</em> bytes at <em>offset</em> of the vector to an unsigned integer. If <em>length</em> is larger than 4, the excess is ignored.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 $00 $00 $01 == 0x00000001 == 1, if false, $01 00 00 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_tag_lib_1_1_byte_vector.html#a680335d571501172e98df012aae52335">fromUInt()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa504bf38f98c782647ea46fbe7c9dc5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short TagLib::ByteVector::toUShort </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the first 2 bytes of the vector to a unsigned short.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 $01 == 0x0001 == 1, if false, $01 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_tag_lib_1_1_byte_vector.html#a162543bf4b280468a677799686178522">fromShort()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aaff09612c4a59eb9598aa1063c53bf0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short TagLib::ByteVector::toUShort </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the 2 bytes at <em>offset</em> of the vector to a unsigned short.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 $01 == 0x0001 == 1, if false, $01 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_tag_lib_1_1_byte_vector.html#a162543bf4b280468a677799686178522">fromShort()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a36db251bf327d8f00dcee07367fd7cd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TAGLIB_EXPORT std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tag_lib_1_1_byte_vector.html">TagLib::ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Streams the <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a> <em>v</em> to the output stream <em>s</em>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a7593a608427eb6f855c4dc48558ad8a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a> TagLib::ByteVector::null</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A static, empty <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a> which is convenient and fast (since returning an empty or "null" value does not require instantiating a new <a class="el" href="class_tag_lib_1_1_byte_vector.html" title="A byte vector. ">ByteVector</a>). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>code/MiamCore/3rdparty/taglib/<a class="el" href="tbytevector_8h_source.html">tbytevector.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_tag_lib.html">TagLib</a></li><li class="navelem"><a class="el" href="class_tag_lib_1_1_byte_vector.html">ByteVector</a></li>
    <li class="footer">Generated on Thu Nov 21 2013 21:05:13 for Madame MiamMiam&#39;s Music Player by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
